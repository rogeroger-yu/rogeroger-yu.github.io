<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Namespace概念</title>
      <link href="/2022/09/20/namespace/"/>
      <url>/2022/09/20/namespace/</url>
      
        <content type="html"><![CDATA[<h1 id="Namespace操作"><a href="#Namespace操作" class="headerlink" title="Namespace操作"></a>Namespace操作</h1><h2 id="查看Namespace"><a href="#查看Namespace" class="headerlink" title="查看Namespace"></a>查看Namespace</h2><p>查看该目录&#x2F;proc&#x2F;[pid]&#x2F;ns，能够看到该进程所在的namespace，各个namespace文件描述符在该目录下呈链接状态，链接目标的文件类型为namespace，没有具体目录承载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">ls</span> -al /proc/110/ns/</span><br><span class="line">total 0</span><br><span class="line">dr-x--x--x 2 root root 0 May 17  2021 .</span><br><span class="line">dr-xr-xr-x 9 root root 0 May 17  2021 ..</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 17  2021 cgroup -&gt; cgroup:[4026531835]</span><br><span class="line">lrwxrwxrwx 1 root root 0 May 17  2021 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0 May 17  2021 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 root root 0 May 17  2021 net -&gt; net:[4026531993]</span><br><span class="line">lrwxrwxrwx 1 root root 0 May 17  2021 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 17  2021 pid_for_children -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 root root 0 May 17  2021 user -&gt; user:[402653183</span><br></pre></td></tr></table></figure><h2 id="三种Namespace相关的基础系统调用"><a href="#三种Namespace相关的基础系统调用" class="headerlink" title="三种Namespace相关的基础系统调用"></a>三种Namespace相关的基础系统调用</h2><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>创建新进程的同时创建 namespace，将新进程加入新的namespace中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prototype for the glibc wrapper function */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clone</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *child_stack, <span class="type">int</span> flags, <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><ul><li>fn: 指定一个由新进程执行的函数。当这个函数返回时，子进程终止。该函数返回一个整数，表示子进程的退出代码</li><li>child_stack: 传入子进程使用的栈空间，也就是把用户态堆栈指针赋给子进程的 esp 寄存器。调用进程(指调用 clone() 的进程)应该总是为子进程分配新的堆栈</li><li>flags: 表示使用哪些 CLONE_ 开头的标志位，与 namespace 相关的有:<ul><li>CLONE_NEWIPC</li><li>CLONE_NEWNET</li><li>CLONE_NEWNS</li><li>CLONE_NEWPID</li><li>CLONE_NEWUSER</li><li>CLONE_NEWUTS</li><li>CLONE_NEWCGROUP</li></ul></li><li>arg: 指向传递给 fn() 函数的参数</li></ul><blockquote><p>&#x2F;proc&#x2F;[pid]&#x2F;ns的另外一个作用是，一旦文件被打开，只要打开的文件描述符（fd）存在，那么就算PID所属的所有进程都已经结束，创建的namespace就会一直存在。那如何打开文件描述符呢？把&#x2F;proc&#x2F;[pid]&#x2F;ns目录挂载起来就可以达到这个效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> ~/uts</span><br><span class="line">$ mount --<span class="built_in">bind</span> /proc/27514/ns/uts ~/uts</span><br></pre></td></tr></table></figure><p><strong>通常使用该方法将namespace保留下来</strong></p></blockquote><h3 id="setns"><a href="#setns" class="headerlink" title="setns"></a>setns</h3><p>将当前进程加入到已有的 namespace 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setns</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> nstype)</span>;</span><br></pre></td></tr></table></figure><ul><li>fd: 目标namespace 的文件描述符。它是一个指向 &#x2F;proc&#x2F;[pid]&#x2F;ns 目录中文件的文件描述符，可以通过直接打开该目录下的链接文件或者打开一个挂载了该目录下链接文件的文件得到</li><li>nstype: 参数 nstype 让调用者可以检查 fd 指向的 namespace 类型是否符合实际要求。若把该参数设置为 0 表示不检查</li></ul><h3 id="unshare"><a href="#unshare" class="headerlink" title="unshare"></a>unshare</h3><p>创建新的namespace，并将当前进程加入新的namespace</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unshare</span><span class="params">(<span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><ul><li>flags: 同上</li></ul><h2 id="隔离进程实战"><a href="#隔离进程实战" class="headerlink" title="隔离进程实战"></a>隔离进程实战</h2><h3 id="准备unshare"><a href="#准备unshare" class="headerlink" title="准备unshare"></a>准备unshare</h3><p>unshare默认只能由超级用户执行，要想所有用户都可以创建namespace，需要设置该程序的capability</p><blockquote><p>Linux 将传统上与超级用户 root 关联的特权划分为不同的单元，称为 capabilites。Capabilites 作为线程(Linux 并不真正区分进程和线程)的属性存在，每个单元可以独立启用和禁用。如此一来，权限检查的过程就变成了：在执行特权操作时，如果进程的有效身份不是 root，就去检查是否具有该特权操作所对应的 capabilites，并以此决定是否可以进行该特权操作。比如要向进程发送信号(kill())，就得具有 capability <strong>CAP_KILL</strong>；如果设置系统时间，就得具有 capability <strong>CAP_SYS_TIME</strong></p></blockquote><p>这里需要设置cap_sys_admin权限用于操作pid namespace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> `<span class="built_in">which</span> unshare` ./ <span class="comment"># 避免污染原文件</span></span><br><span class="line">$ <span class="built_in">setcap</span> <span class="string">&#x27;cap_sys_admin+ep&#x27;</span> ./unshare</span><br></pre></td></tr></table></figure><h3 id="设置PID-Namespace"><a href="#设置PID-Namespace" class="headerlink" title="设置PID Namespace"></a>设置PID Namespace</h3><ul><li>创建pid namespace</li><li>在namespace中挂载<code>proc</code>文件系统</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./unshare --pid --mount-proc --fork bash</span><br><span class="line">$ ps -ef</span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">lsfadmin       1       0  0 22:36 pts/1    00:00:00 bash</span><br><span class="line">lsfadmin       3       1  0 22:36 pts/1    00:00:00 ps -ef</span><br></pre></td></tr></table></figure><p>挂载proc文件系统的原因是：只是创建pid namespace，不能保证只看到namespace中的进程。因为类似<code>ps</code>这类系统工具读取的是<code>proc</code>文件系统。<code>proc</code>文件系统没有切换的话，虽然有了pid namespace，但是不能达到我们在这个namespace中只看到属于自己namespace进程的目的。</p><p>在创建pid namespace的同时，使用<code>--mount-proc</code>选项，会创建新的mount namespace，并自动<code>mount</code>新的<code>proc</code>文件系统。这样，<code>ps</code>就可以看到当前pid namespace里面所有的进程了。因为是新的pid namespace，进程的PID也是从1开始编号。对于pid namespace里面的进程来说，就好像只有自己这些个进程在使用操作系统。</p><h3 id="设置Mount-Namespace"><a href="#设置Mount-Namespace" class="headerlink" title="设置Mount Namespace"></a>设置Mount Namespace</h3><p>上述PID Namespace隔离后，仍然能够看到操作系统的文件系统，为了只看到属于namespace自己的文件系统，需要创建mount namespace。<code>--mount-proc</code>的时候，其实就已经创建了新的mount namespace。可是，bash中还是能够看到操作系统的目录和文件。</p><h4 id="1-创建自己的根文件系统"><a href="#1-创建自己的根文件系统" class="headerlink" title="1. 创建自己的根文件系统"></a>1. 创建自己的根文件系统</h4><p>这里使用docker的ubuntu镜像作为例子。在容器中安装了<code>iproute2</code>，是为了方便后面network namespace的实验。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it ubuntu bash</span><br><span class="line">[container] apt update</span><br><span class="line">[container] apt install iproute2</span><br></pre></td></tr></table></figure><p>将运行的容器的镜像导出来，解压到Linux当前目录的ubuntu子目录中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES</span><br><span class="line">3ed040cc2824   ubuntu    ...</span><br><span class="line">$ docker <span class="built_in">export</span> 3ed040cc2824 --output=ubuntu.tar</span><br><span class="line">$ <span class="built_in">mkdir</span> ubuntu</span><br><span class="line">$ tar -xf ubuntu.tar -C ubuntu</span><br></pre></td></tr></table></figure><h4 id="2-unshare设置chroot权限"><a href="#2-unshare设置chroot权限" class="headerlink" title="2. unshare设置chroot权限"></a>2. unshare设置chroot权限</h4><p><code>unshare</code>要使用<code>chroot</code>操作，将namespace中的根文件系统切换，而不影响操作系统。为了让非root用户完成这个操作，额外需要<code>cap_sys_chroot</code>权能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">setcap</span> <span class="string">&#x27;cap_sys_admin+ep cap_sys_chroot+ep&#x27;</span> ./unshare</span><br></pre></td></tr></table></figure><h4 id="3-mount系统根目录"><a href="#3-mount系统根目录" class="headerlink" title="3. mount系统根目录"></a>3. mount系统根目录</h4><p>使用<code>unshare</code>创建mount namespace，并将系统根目录切换到刚刚创建的根文件系统目录中。这样，namespace中能看到的全部目录，其实只是操作系统中的一个子目录。并且后续的<code>mount</code>操作，也只会影响mount namespace。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./unshare --mount --root /home/lsfadmin/shared/ns/ubuntu --pid --mount-proc --fork bash</span><br><span class="line"></span><br><span class="line">I have no name!@linux1 :/$ mount</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">I have no name!@linux1 :/$ <span class="built_in">cat</span> /etc/lsb-release </span><br><span class="line">DISTRIB_ID=Ubuntu</span><br><span class="line">DISTRIB_RELEASE=20.04</span><br><span class="line">DISTRIB_CODENAME=focal</span><br><span class="line">DISTRIB_DESCRIPTION=<span class="string">&quot;Ubuntu 20.04.3 LTS&quot;</span></span><br></pre></td></tr></table></figure><p>显然，这里新的<code>ubuntu</code> 镜像和操作系统使用的小版本是不一下样的。隔离出来了。原本应该搞一个centos之类的镜像，那样看起来区别大一些。</p><p>到目前为止，Linux操作系统中的bash和namespace中的bash看到文件系统已经不同。当然，还可以通过在操作系统中执行<code>lsns</code>命令查看新创建的namespace。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ pstree -p 904489</span><br><span class="line">unshare(904489)───bash(904490)</span><br><span class="line">$ lsns -p 904490</span><br><span class="line">        NS TYPE   NPROCS    PID USER     COMMAND</span><br><span class="line">4026532420 mnt         1 904490 lsfadmin bash</span><br><span class="line">4026532421 pid         1 904490 lsfadmin bash</span><br></pre></td></tr></table></figure><p>嗯，确实是给<code>unshare</code>出来的进程创建了新的namespace</p><h3 id="设置User-Namespace"><a href="#设置User-Namespace" class="headerlink" title="设置User Namespace"></a>设置User Namespace</h3><p>查看当前用户id</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">id</span></span><br><span class="line">uid=1001(yuqian.0001) gid=1001(yuqian.0001) <span class="built_in">groups</span>=1001(yuqian.0001),999(docker),1000(tiger),2001(admin)</span><br></pre></td></tr></table></figure><p>在user namespace里面，可以自己管理用户的。也就是说，我想是谁就是谁。要做到这一步还是一个组合拳。先创建user namespace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./unshare --user --mount --root /home/lsfadmin/shared/ns/ubuntu --pid --mount-proc --fork bash</span><br><span class="line">$ <span class="built_in">id</span></span><br><span class="line">uid=65534(nobody) gid=65534(nogroup) <span class="built_in">groups</span>=65534(nogroup)</span><br></pre></td></tr></table></figure><p>新开一个终端，查看新建namespace的bash进程id为<code>1904696</code></p><p>user namespace默认初始化的用户是<code>nobody</code>(65534)。让当前账户成为改namespace的root用户：</p><blockquote><p>uid_map文件格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ID-inside-ns ID-outside-ns length</span><br></pre></td></tr></table></figure><ul><li>第一个字段ID-inside-ns表示在容器显示的UID或GID，</li><li>第二个字段ID-outside-ns表示容器外映射的真实的UID或GID。</li><li>第三个字段表示映射的范围，一般填1，表示一一对应。</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;0 1000 1&#x27;</span> &gt; /proc/1904696/uid_map</span><br></pre></td></tr></table></figure><p>再切回到namespace里面（在新开的终端中），可以发现uid已经切换了。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nobody@linux1:/$ id</span><br><span class="line">uid=1000(lp) gid=65534(nogroup) groups=65534(nogroup)</span><br></pre></td></tr></table></figure><p>不错，可以用新身份创建文件了：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nobody@linux1:/$ touch from-namespace</span><br><span class="line">nobody@linux1:/$ ls -nl from-namespace </span><br><span class="line">-rw-rw-r-- 1 0 65534 0 Nov 30 14:00 from-namespace</span><br></pre></td></tr></table></figure><p>第三列，用户7创建文件，如我所料。</p><p>但是，事实上，一直以来，<code>我</code>从未改变。Namespace外：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ubuntu</span><br><span class="line">$ ls -nl from-namespace </span><br><span class="line">-rw-rw-r-- 1 1000 1000 0 Nov 30 06:00 from-namespace</span><br></pre></td></tr></table></figure><p>文件创建的用户依然是<code>lsfadmin</code>，依然是<code>1000</code>。操作系统会确保，无论怎样，都是以登陆用户授权访问文件系统。Namespace仅仅是让在那个隔离里面看起来不一样而已。</p><h1 id="UST-Namespace"><a href="#UST-Namespace" class="headerlink" title="UST Namespace"></a>UST Namespace</h1><p>UTS(UNIX Time Sharing) namespace是最简单的一种 namespace。UTS 中主要包含了主机名（hostname）、域名（domainname）和一些版本信息，其中主机名（hostname）、domainname(域名)可以被修改，其余只读</p><h2 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h2><h2 id="domainname"><a href="#domainname" class="headerlink" title="domainname"></a>domainname</h2><h2 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h2>]]></content>
      
      
      <categories>
          
          <category> container </category>
          
      </categories>
      
      
        <tags>
            
            <tag> namespace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>source/_posts/test1/test1</title>
      <link href="/2022/09/20/source-posts-test1-test1/"/>
      <url>/2022/09/20/source-posts-test1-test1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/20/hello-world/"/>
      <url>/2022/09/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
